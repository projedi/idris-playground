\frame {
   \frametitle{Idris}
   \begin{itemize}
   \item Haskellоподобный,
   \item с зависимыми типами,
   \item с опциональной проверкой на тотальность,
   \item строгий по-умолчанию,
   \item с тактиками,
   \item \dots
   \end{itemize}
}

\begin{frame}[fragile]
   \frametitle{Haskellоподобный}
   \lstset{
      emph={Functor, MyList, Nil},
      emphstyle=\color{typecolor},
      emph={[2]map},
      emphstyle={[2]\color{namecolor}},
   }
   \lstinputlisting[firstline=3, lastline=11]{mylist.idr}
\end{frame}

\begin{frame}[fragile]
   \frametitle{Haskellоподобный}
   \lstset{
      emph={Applicative, Int, Nil, Monad, MyList},
      emphstyle=\color{typecolor},
      emph={[2]id, map, pure, return, test},
      emphstyle={[2]\color{namecolor}},
   }
   \lstinputlisting[frame=single, firstline=3, lastline=3]{mylist.idr}
   \lstinputlisting[firstline=13]{mylist.idr}
\end{frame}

\begin{frame}[fragile]
   \frametitle{С зависимыми типами}
   \lstset{
      emph={Fin, MyVect, Nat, Nil, Type, fZ, fS},
      emphstyle=\color{typecolor},
      emph={[2]},
      emphstyle={[2]\color{namecolor}},
   }
   \lstinputlisting[firstline=3]{myvect.idr}
\end{frame}

\begin{frame}[fragile]
   \frametitle{С опциональной проверкой на тотальность}
   \lstset{
      emph={Int, List},
      emphstyle=\color{typecolor},
      emph={[2]go, myHead},
      emphstyle={[2]\color{namecolor}},
   }
   \begin{lstlisting}
total myHead : List a -> a
myHead (x :: xs) = x
   \end{lstlisting}
   \texttt{Main.myHead is not total as there are missing cases}
   \vspace{\baselineskip}

   \begin{lstlisting}
%default total
go : Int
go = go
   \end{lstlisting}
   \texttt{Main.go is possibly not total due to recursive path Main.go}
   \vspace{\baselineskip}

   В интерпретаторе:\\
   \texttt{> :total f}
   \vspace{\baselineskip}

   В типах вычисляются только тотальные функции.
\end{frame}

\begin{frame}[fragile]
   \frametitle{Строгий по-умолчанию}
   \lstset{
      emph={Bool, False, Int, True},
      emphstyle=\color{typecolor},
      emph={[2]broken, ifThenElse},
      emphstyle={[2]\color{namecolor}},
   }
   \lstinputlisting[firstline=5, lastline=11]{strict.idr}
   \texttt{> ifThenElse True 0 (broken (-1))}\\\vspace{0.5em}
   Интерпретатор:\\
   \texttt{0 : Int}\\\vspace{0.5em}
   Скомпилированный код (с точностью до оптимизаций):\\
   \texttt{segmentation fault ./a.out}
\end{frame}

\begin{frame}[fragile]
   \frametitle{С тактиками}
   \lstset{
      emph={MyList, refl},
      emphstyle=\color{typecolor},
      emph={[2]id, lemma_applicative_identity, lemma_applicative_identity_rhs, pure},
      emphstyle={[2]\color{namecolor}},
   }
   \lstinputlisting{tactics.idr}
\end{frame}

\begin{frame}[fragile]
   \frametitle{\dots}
   \lstset{
      emph={Int, Maybe, Ord},
      emphstyle=\color{typecolor},
      emph={[2]myord, sort},
      emphstyle={[2]\color{namecolor}},
   }
   \begin{itemize}
   \item Именованные инстансы
         \begin{lstlisting}
instance [myord] Ord Int where
   ...
sort @{myord} [2, 1, 3]
         \end{lstlisting}
   \item Idiom brackets(для аппликативных функторов)
         \begin{lstlisting}
f : Maybe Int -> Maybe Int -> Maybe Int
f x y = [| x + y |]
         \end{lstlisting}
   \end{itemize}
\end{frame}

\begin{frame}[fragile]
   \frametitle{\dots}
   \lstset{
      emph={Bool, Delay, Lazy, Maybe, Type},
      emphstyle=\color{typecolor},
      emph={[2]Force, boolElim, g},
      emphstyle={[2]\color{namecolor}},
   }
   \begin{itemize}
   \item !-нотация(для монад)
         \begin{lstlisting}
g : Maybe Bool -> Maybe a -> Maybe a -> Maybe a
g x t f = if !x then t else f
         \end{lstlisting}
   \item Опциональная ленивость
         \begin{lstlisting}
data Lazy : Type -> Type where
   Delay : a -> Lazy a

Force : Lazy a -> a
         \end{lstlisting}
   \item Изменяемый синтаксис
         \begin{lstlisting}
syntax if [test] then [t] else [e] = boolElim test (Delay t) (Delay e)
         \end{lstlisting}
   \end{itemize}
\end{frame}

\begin{frame}[fragile]
   \frametitle{\dots}
   \lstset{
      emph={Type},
      emphstyle=\color{typecolor},
      emph={[2]},
      emphstyle={[2]\color{namecolor}},
   }
   \begin{itemize}
   \item Минимальный вывод типов в \texttt{\color{kwcolor}where}
   \item Гетерогенное равенство
      \begin{lstlisting}
data (=) : a -> b -> Type where
   refl : x = x
      \end{lstlisting}
   \item FFI with C
      TODO
   \end{itemize}
\end{frame}

\begin{frame}[fragile]
   \frametitle{\dots}
   \lstset{
      emph={Int, MkR, R, String, Type},
      emphstyle=\color{typecolor},
      emph={[2]f},
      emphstyle={[2]\color{namecolor}},
   }
   \begin{itemize}
   \item \texttt{\color{kwcolor}public}, \texttt{\color{kwcolor}abstract},
         \texttt{\color{kwcolor}private} спецификаторы видимости
      \begin{lstlisting}
%access public
abstract f : Int -> Int
      \end{lstlisting}
   \item \texttt{\color{kwcolor}record}s
      \begin{lstlisting}
record R : Type where
   MkR : (f1 : Int) -> (f2 : String) -> R
      \end{lstlisting}
   \item Levels are implicit
      TODO
   \item auto implicit args
      TODO
   \end{itemize}
\end{frame}

\begin{frame}[fragile]
   \frametitle{Effects вместо трансформеров}%TODO: Can be a topic in itself
   %TODO: What are STDIO & co? types or not
   \lstset{
      emph={Eff, Int, STDIO, STATE},
      emphstyle=\color{typecolor},
      emph={[2]f},
      emphstyle={[2]\color{namecolor}},
   }
   \begin{lstlisting}
f : { [STDIO, STATE Int] } Eff ()
   \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
   \frametitle{Type providers} %TODO: Can be a topic in itself
   \lstset{
      emph={Provide, Provider, IO, Int, Nat, Type, String},
      emphstyle=\color{typecolor},
      emph={[2]T, f, fromFile, return, strToType, trim, readFile},
      emphstyle={[2]\color{namecolor}},
   }
   \lstinputlisting[firstline=3,lastline=17]{providers.idr}
   \lstset{
      emph={},
      emphstyle=\color{typecolor},
      emph={[2]},
      emphstyle={[2]\color{namecolor}},
   }
   \lstinputlisting[title=config.h,frame=single]{config.h}
\end{frame}

\frame {
   \frametitle{TODOs}
   \begin{itemize}
   \item Proof automation
   \item More better termination checker
   \item More better editor support (goto definition, autocomplete, \dots)
   \item More bindings (incl. low-level C bindings)
   \item More backends (e.g. GHC)
   \item Bugfixing
   \end{itemize}
}
