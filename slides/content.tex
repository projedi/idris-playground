\frame {
   \frametitle{Idris}
   \begin{itemize}
   \item Haskellоподобный,
   \item с зависимыми типами,
   \item строгий по-умолчанию,
   \item с опциональной проверкой на тотальность,
   \item \dots
   \end{itemize}
}

\frame {
   \frametitle{Haskellоподобный}
   \begin{align*}
   &\mathbf{data}\ MyList\ a\ = Nil\ |\ (::)\ a\ (MyList\ a)\\
   &\\
   &(\texttt{++}) : MyList\ a \rightarrow MyList\ a \rightarrow MyList\ a\\
   &[]\ \texttt{++}\ ys = ys\\
   &(x :: xs)\ \texttt{++}\ ys = x :: (xs\ \texttt{++}\ ys)\\
   &\\
   &\mathbf{instance}\ Functor\ MyList\ \mathbf{where}\\
   &\quad map\ f\ Nil = Nil\\
   &\quad map\ f\ (x :: xs) = f\ x :: map\ f\ xs\\
   \end{align*}
}

\frame {
   \frametitle{Haskellоподобный}
   \begin{align*}
   &\mathbf{instance}\ Applicative\ MyList\ \mathbf{where}\\
   &\quad pure\ x = [x]\\
   &\quad []\ \texttt{<\$>}\ \_ = []\\
   &\quad (f :: fs)\ \texttt{<\$>}\ xs = map\ f\ xs\ \texttt{++}\ (fs\ \texttt{<\$>}\ xs)\\
   &\\
   &\mathbf{instance}\ Monad\ MyList\ \mathbf{where}\\
   &\quad []\ \texttt{>>=}\ \_ = []\\
   &\quad (x :: xs)\ \texttt{>>=}\ f = f\ x\ \texttt{++}\ (xs\ \texttt{>>=}\ f)\\
   &\\
   &test : MyList\ Int\\
   &test = do\\
   &\quad f \leftarrow [id, (*2)]\\
   &\quad x \leftarrow [3, 4]\\
   &\quad return\ \$\ f\ x
   \end{align*}
}

\frame {
   \frametitle{С зависимыми типами}
}

\frame {
   \frametitle{Строгий по-умолчанию}
}

\frame {
   \frametitle{С опциональной проверкой на тотальность}
}

\frame {
   \frametitle{\dots}
}
