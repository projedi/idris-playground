\frame {
   \frametitle{Idris}
   \begin{itemize}
   \item Haskellоподобный,
   \item с зависимыми типами,
   \item строгий по-умолчанию,
   \item с опциональной проверкой на тотальность,
   \item с тактиками,
   \item \dots
   \end{itemize}
}

\begin{frame}[fragile]
   \frametitle{Haskellоподобный}
   \begin{lstlisting}
data MyList a = Nil | (::) a (MyList a)

(++) : MyList a -> MyList a -> MyList a
[] ++ ys = ys
(x :: xs) ++ ys = x :: (xs ++ ys)

instance Functor MyList where
   map f Nil = Nil
   map f (x :: xs) =f x :: map f xs
   \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
   \frametitle{Haskellоподобный}
   \begin{lstlisting}
instance Applicative MyList where
   pure x = [x]
   [] <$> _ = []
   (f :: fs) <$> xs = map f xs ++ (fs <$> xs)

instance Monad MyList where
   [] >>= _ = []
   (x :: xs) >>= f = f x ++ (xs >>= f)

test : MyList Int
test = do
   f <- [id, (*2)]
   x <- [3, 4]
   return $ f x
   \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
   \frametitle{С зависимыми типами}
   \begin{lstlisting}
data MyVect : Nat -> (a : Type) -> Type where
   Nil : MyVect 0 a
   (::) : a -> MyVect n a -> MyVect (S n) a

(++) : MyVect n a -> MyVect m a -> MyVect (n + m) a
[] ++ ys = ys
(x :: xs) ++ ys = x :: (xs ++ ys)

infix 9 !!

(!!) : MyVect n a -> Fin n -> a
(x :: xs) !! fZ = x
(x :: xs) !! (fS y) = xs !! y
   \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
   \frametitle{Строгий по-умолчанию}
   \begin{lstlisting}
broken : Int -> Int
broken 0 = 1
broken n = n * broken (n - 1)

ifThenElse : Bool -> a -> a -> a
ifThenElse True t _ = t
ifThenElse False _ f = f
   \end{lstlisting}
   \begin{lstlisting}
> ifThenElse True 0 (broken (-1))
   \end{lstlisting}
   Интерпретатор:
   \begin{lstlisting}
0 : Int
   \end{lstlisting}
   Скомпилированный код (с точностью до оптимизаций):\\
   \texttt{segmentation fault ./a.out}
\end{frame}

\begin{frame}[fragile]
   \frametitle{С опциональной проверкой на тотальность}
   \begin{lstlisting}
total myHead : List a -> a
myHead (x :: xs) = x
   \end{lstlisting}
   \texttt{Main.myHead is not total as there are missing cases}
   \begin{lstlisting}
%default total
go : Int
go = go
   \end{lstlisting}
   \texttt{Main.go is possibly not total due to recursive path Main.go}
\end{frame}

\begin{frame}[fragile]
   \frametitle{С тактиками}
   \begin{lstlisting}
lemma_applicative_identity :  (vs : MyList a)
                           -> (pure id <$> vs = vs)
lemma_applicative_identity [] = refl
lemma_applicative_identity (v ::vs) =
   let rec = lemma_applicative_identity vs
   in ?lemma_applicative_identity_rhs

lemma_applicative_identity_rhs = proof
   intro a,x,xs,rec
   rewrite rec
   trivial
   \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
   \frametitle{\dots}
   \begin{itemize}
   \item Effects вместо трансформеров %TODO: Can be a topic in itself
         \begin{lstlisting}
f : { [STDIO, STATE Int] } Eff ()
         \end{lstlisting}
   \item Именованные инстансы
         \begin{lstlisting}
instance [myord] Ord Int where
   ...
sort @{myord} [2, 1, 3]
         \end{lstlisting}
   \item Idiom brackets(для аппликативных функторов)
         \begin{lstlisting}
f : Maybe Int -> Maybe Int -> Maybe Int
f x y = [| x + y |]
         \end{lstlisting}
   \end{itemize}
\end{frame}

\begin{frame}[fragile]
   \frametitle{\dots}
   \begin{itemize}
   \item !-нотация(для монад)
         \begin{lstlisting}
f : Maybe Bool -> Maybe a -> Maybe a -> Maybe a
f x t f = if !x then t else f
         \end{lstlisting}
   \item Опциональная ленивость
         \begin{lstlisting}
data Lazy : Type -> Type where
   Delay : a -> Lazy a

Force : Lazy a -> a
         \end{lstlisting}
   \item Изменяемый синтаксис
         \begin{lstlisting}
syntax if [test] then [t] else [e] = boolElim test (Delay t) (Delay e)
         \end{lstlisting}
   \end{itemize}
\end{frame}

\begin{frame}[fragile]
   \frametitle{\dots}
   \begin{itemize}
   \item Минимальный вывод типов в \textbf{where}
   \item Гетерогенное равенство
      \begin{lstlisting}
data (=) : a -> b -> Type where
   refl : x = x
      \end{lstlisting}
   \item FFI with C
      TODO
   \end{itemize}
\end{frame}

\begin{frame}[fragile]
   \frametitle{\dots}
   \begin{itemize}
   \item \textbf{public}, \textbf{abstract}, \textbf{private} спецификаторы видимости
      \begin{lstlisting}
%access public
abstract f : Int -> Int
      \end{lstlisting}
   \item \textbf{record}s
      \begin{lstlisting}
record R : Type where
   MkR : (f1 : Int) -> (f2 : String) -> R
      \end{lstlisting}
   \item Levels are implicit
      TODO
   \item auto implicit args
      TODO
   \end{itemize}
\end{frame}

\begin{frame}[fragile]
   \frametitle{Type providers} %TODO: Can be a topic in itself
   \begin{lstlisting}
%language TypeProviders

strToType : String -> Type
strToType "Int" = Int
strToType _ = Nat

fromFile : String -> IO (Provider Type)
fromFile fname = Provide (strToType (trim !(readFile fname)))

%provide (T : Type) with fromFile "config.h"

f : T
f = 42
   \end{lstlisting}
\end{frame}

\frame {
   \frametitle{TODOs}
   \begin{itemize}
   \item Proof automation
   \item More better termination checker
   \item More better editor support (goto definition, autocomplete, \dots)
   \item More bindings (incl. low-level C bindings)
   \item More backends (e.g. GHC)
   \item Bugfixing
   \end{itemize}
}
