\frame {
   \frametitle{Idris}
   \begin{itemize}
   \item Haskellоподобный,
   \item с зависимыми типами,
   \item строгий по-умолчанию,
   \item с опциональной проверкой на тотальность,
   \item с тактиками,
   \item \dots
   \end{itemize}
}

\frame {
   \frametitle{Haskellоподобный}
   \begin{align*}
   &\mathbf{data}\ MyList\ a\ = Nil\ |\ (::)\ a\ (MyList\ a)\\
   &\\
   &(\texttt{++}) : MyList\ a \to MyList\ a \to MyList\ a\\
   &[]\ \texttt{++}\ ys = ys\\
   &(x :: xs)\ \texttt{++}\ ys = x :: (xs\ \texttt{++}\ ys)\\
   &\\
   &\mathbf{instance}\ Functor\ MyList\ \mathbf{where}\\
   &\quad map\ f\ Nil = Nil\\
   &\quad map\ f\ (x :: xs) = f\ x :: map\ f\ xs\\
   \end{align*}
}

\frame {
   \frametitle{Haskellоподобный}
   \begin{align*}
   &\mathbf{instance}\ Applicative\ MyList\ \mathbf{where}\\
   &\quad pure\ x = [x]\\
   &\quad []\ \texttt{<\$>}\ \_ = []\\
   &\quad (f :: fs)\ \texttt{<\$>}\ xs = map\ f\ xs\ \texttt{++}\ (fs\ \texttt{<\$>}\ xs)\\
   &\\
   &\mathbf{instance}\ Monad\ MyList\ \mathbf{where}\\
   &\quad [] \bind \_ = []\\
   &\quad (x :: xs) \bind f = f\ x\ \texttt{++}\ (xs \bind f)\\
   &\\
   &test : MyList\ Int\\
   &test = \mathbf{do}\\
   &\quad f \leftarrow [id, (*2)]\\
   &\quad x \leftarrow [3, 4]\\
   &\quad return\ \$\ f\ x
   \end{align*}
}

\frame {
   \frametitle{С зависимыми типами}
   \begin{align*}
   &\mathbf{data}\ MyVect : Nat \to (a : Type) \to Type\ \mathbf{where}\\
   &\quad Nil : MyVect\ 0\ a\\
   &\quad (::) : a \to MyVect\ n\ a \to MyVect\ (S\ n)\ a\\
   &\\
   &(\texttt{++}) : MyVect\ n\ a \to MyVect\ m\ a \to MyVect\ (n + m)\ a\\
   &[]\ \texttt{++}\ ys = ys\\
   &(x :: xs)\ \texttt{++}\ ys = x :: (xs\ \texttt{++}\ ys)\\
   &\\
   &\mathbf{infix}\ 9\ !!\\
   &\\
   &(!!) : MyVect\ n\ a \to Fin\ n \to a\\
   &(x :: xs)\ !!\ fZ = x\\
   &(x :: xs)\ !!\ (fS\ y) = xs\ !!\ y
   \end{align*}
}

\frame {
   \frametitle{Строгий по-умолчанию}
   \begin{align*}
   &broken : Int \to Int\\
   &broken\ 0 = 1\\
   &broken\ n = n * broken\ (n - 1)\\
   &\\
   &ifThenElse : Bool \to a \to a \to a\\
   &ifThenElse\ True\ t\ \_ = t\\
   &ifThenElse\ False\ \_\ f = f\\
   &\\
   &> ifThenElse\ True\ 0\ (broken\ (-1))\\
   &\text{Интерпретатор:}\\
   &\quad0 : Int\\
   &\text{Скомпилированный код(с точностью до оптимизаций):}\\
   &\quad\texttt{segmentation fault ./a.out}\\
   \end{align*}
}

\frame {
   \frametitle{С опциональной проверкой на тотальность}
   \begin{align*}
   &\mathbf{total}\ myHead : List\ a \to a\\
   &myHead\ (x :: xs) = x\\
   &\\
   &> \text{Main.myHead is not total as there are missing cases}\\
   &\\
   &\%\mathbf{default}\ total\\
   &go : Int\\
   &go = go\\
   &\\
   &> \text{Main.go is possibly not total due to recursive path Main.go}\\
   \end{align*}
}

\frame {
   \frametitle{С тактиками}
   \begin{align*}
   &lemma\_applicative\_identity : (vs : MyList\ a) \to (pure\ id\ \texttt{<\$>}\ vs = vs)\\
   &lemma\_applicative\_identity\ [] = refl\\
   &lemma\_applicative\_identity\ (v :: vs) =\\
   &\quad \mathbf{let}\ rec = lemma\_applicative\_identity\ vs\\
   &\quad \mathbf{in}\ \texttt{?lemma\_applicative\_identity\_rhs}\\
   &\\
   &lemma\_applicative\_identity\_rhs = proof\\
   &\quad \mathbf{intro}\ a,x,xs,rec\\
   &\quad \mathbf{rewrite}\ rec\\
   &\quad \mathbf{trivial}
   \end{align*}
}

\frame {
   \frametitle{\dots}
   \begin{itemize}
   \item Effects вместо трансформеров %TODO: Can be a topic in itself
         \[
         f : \{\ [STDIO, STATE\ Int]\ \}\ Eff\ ()
         \]
   \item Именованные инстансы
         \begin{align*}
         &\mathbf{instance}\ [myord]\ Ord\ Int\ \mathbf{where}\\
         &\quad \dots\\
         &sort\ @\{myord\}\ [2, 1, 3]
         \end{align*}
   \item Idiom brackets(для аппликативных функторов)
         \begin{align*}
         &f : Maybe\ Int \to Maybe\ Int \to Maybe\ Int\\
         &f\ x\ y = [| x + y |]
         \end{align*}
   \end{itemize}
}

\frame {
   \frametitle{\dots}
   \begin{itemize}
   \item !-нотация(для монад)
         \begin{align*}
         &f : Maybe\ Bool \to Maybe\ a \to Maybe\ a \to Maybe\ a\\
         &f\ x\ t\ f = \mathbf{if}\ !x\ \mathbf{then}\ t\ \mathbf{else}\ f
         \end{align*}
   \item Опциональная ленивость
         \begin{align*}
         &\mathbf{data}\ Lazy : Type \to Type\ \mathbf{where}\\
         &\quad Delay : a \to Lazy\ a\\
         &\\
         &Force : Lazy\ a \to a
         \end{align*}
   \item Изменяемый синтаксис
         \[
         \mathbf{syntax}\ if\ [test]\ then\ [t]\ else\ [e] = boolElim\ test\ (Delay\ t)\ (Delay\ e)
         \]
   \end{itemize}
}

\frame {
   \frametitle{\dots}
   \begin{itemize}
   \item Минимальный вывод типов в \textbf{where}
   \item Гетерогенное равенство
      \begin{align*}
      &\mathbf{data}\ (=) : a \to b \to Type\ \mathbf{where}\\
      &\quad refl : x = x
      \end{align*}
   \item FFI with C
      TODO
   \end{itemize}
}

\frame {
   \frametitle{\dots}
   \begin{itemize}
   \item \textbf{public}, \textbf{abstract}, \textbf{private} спецификаторы видимости
      \begin{align*}
      &\%\mathbf{access}\ public\\
      &\mathbf{abstract}\ f : Int \to Int
      \end{align*}
   \item \textbf{record}s
      \begin{align*}
      &\mathbf{record}\ R : Type\ \mathbf{where}\\
      &\quad MkR : (f1 : Int) \to (f2 : String) \to R
      \end{align*}
   \item Levels are implicit
      TODO
   \item auto implicit args
      TODO
   \end{itemize}
}

\frame {
   \frametitle{Type providers} %TODO: Can be a topic in itself
   \begin{align*}
   &\%\mathbf{language}\ TypeProviders\\
   \\
   &strToType : String \to Type\\
   &strToType\ ``Int`` = Int\\
   &strToType\ \_ = Nat\\
   \\
   &fromFile : String \to IO\ (Provider\ Type)\\
   &fromFile\ fname = Provide\ (strToType\ (trim\ !(readFile\ fname)))\\
   \\
   &\%\mathbf{provide}\ (T : Type)\ \mathbf{with}\ fromFile\ ``config.h``\\
   \\
   &f : T\\
   &f = 42
   \end{align*}
}

\frame {
   \frametitle{TODOs}
   \begin{itemize}
   \item Proof automation
   \item More better termination checker
   \item More better editor support (goto definition, autocomplete, \dots)
   \item More bindings (incl. low-level C bindings)
   \item More backends (e.g. GHC)
   \item Bugfixing
   \end{itemize}
}
