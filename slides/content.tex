\frame {
   \frametitle{Idris}
   \begin{itemize}
   \item Haskellоподобный,
   \item с зависимыми типами,
   \item строгий по-умолчанию,
   \item с опциональной проверкой на тотальность,
   \item с тактиками,
   \item \dots
   \end{itemize}
}

\begin{frame}[fragile]
   \frametitle{Haskellоподобный}
   \lstset{
      emph={Functor, MyList, Nil},
      emphstyle=\color{typecolor},
      emph={[2]map},
      emphstyle={[2]\color{namecolor}},
   }
   \begin{lstlisting}
data MyList a = Nil | (::) a (MyList a)

(++) : MyList a -> MyList a -> MyList a
Nil ++ ys = ys
(x :: xs) ++ ys = x :: (xs ++ ys)

instance Functor MyList where
   map f Nil = Nil
   map f (x :: xs) = f x :: map f xs
   \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
   \frametitle{Haskellоподобный}
   \lstset{
      emph={Applicative, Int, Nil, Monad, MyList},
      emphstyle=\color{typecolor},
      emph={[2]id, map, pure, return, test},
      emphstyle={[2]\color{namecolor}},
   }
   \begin{lstlisting}[frame=single]
data MyList a = Nil | (::) a (MyList a)
   \end{lstlisting}
   \begin{lstlisting}
instance Applicative MyList where
   pure x = [x]
   [] <$> _ = []
   (f :: fs) <$> xs = map f xs ++ (fs <$> xs)

instance Monad MyList where
   [] >>= _ = []
   (x :: xs) >>= f = f x ++ (xs >>= f)

test : MyList Int
test = do
   f <- [id, (*2)]
   x <- [3, 4]
   return $ f x
   \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
   \frametitle{С зависимыми типами}
   \lstset{
      emph={Fin, MyVect, Nat, Nil, Type, fZ, fS},
      emphstyle=\color{typecolor},
      emph={[2]},
      emphstyle={[2]\color{namecolor}},
   }
   \begin{lstlisting}
data MyVect : Nat -> (a : Type) -> Type where
   Nil : MyVect 0 a
   (::) : a -> MyVect n a -> MyVect (S n) a

(++) : MyVect n a -> MyVect m a -> MyVect (n + m) a
[] ++ ys = ys
(x :: xs) ++ ys = x :: (xs ++ ys)

infix 9 !!

(!!) : MyVect n a -> Fin n -> a
(x :: xs) !! fZ = x
(x :: xs) !! (fS y) = xs !! y
   \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
   \frametitle{Строгий по-умолчанию}
   \lstset{
      emph={Bool, False, Int, True},
      emphstyle=\color{typecolor},
      emph={[2]broken, ifThenElse},
      emphstyle={[2]\color{namecolor}},
   }
   \begin{lstlisting}
broken : Int -> Int
broken 0 = 1
broken n = n * broken (n - 1)

ifThenElse : Bool -> a -> a -> a
ifThenElse True t _ = t
ifThenElse False _ f = f
   \end{lstlisting}
   \texttt{> ifThenElse True 0 (broken (-1))}\\\vspace{0.5em}
   Интерпретатор:\\
   \texttt{0 : Int}\\\vspace{0.5em}
   Скомпилированный код (с точностью до оптимизаций):\\
   \texttt{segmentation fault ./a.out}
\end{frame}

\begin{frame}[fragile]
   \frametitle{С опциональной проверкой на тотальность}
   \lstset{
      emph={Int, List},
      emphstyle=\color{typecolor},
      emph={[2]go, myHead},
      emphstyle={[2]\color{namecolor}},
   }
   \begin{lstlisting}
total myHead : List a -> a
myHead (x :: xs) = x
   \end{lstlisting}
   \texttt{Main.myHead is not total as there are missing cases}
   \begin{lstlisting}
%default total
go : Int
go = go
   \end{lstlisting}
   \texttt{Main.go is possibly not total due to recursive path Main.go}
\end{frame}

\begin{frame}[fragile]
   \frametitle{С тактиками}
   \lstset{
      emph={MyList, refl},
      emphstyle=\color{typecolor},
      emph={[2]id, lemma_applicative_identity, lemma_applicative_identity_rhs, pure},
      emphstyle={[2]\color{namecolor}},
   }
   \begin{lstlisting}
lemma_applicative_identity :  (vs : MyList a)
                           -> (pure id <$> vs = vs)
lemma_applicative_identity [] = refl
lemma_applicative_identity (v :: vs) =
   let rec = lemma_applicative_identity vs
   in ?lemma_applicative_identity_rhs

lemma_applicative_identity_rhs = proof
   intro a,x,xs,rec
   rewrite rec
   trivial
   \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
   \frametitle{\dots}
   \lstset{
      emph={Int, Maybe, Ord},
      emphstyle=\color{typecolor},
      emph={[2]myord, sort},
      emphstyle={[2]\color{namecolor}},
   }
   \begin{itemize}
   \item Именованные инстансы
         \begin{lstlisting}
instance [myord] Ord Int where
   ...
sort @{myord} [2, 1, 3]
         \end{lstlisting}
   \item Idiom brackets(для аппликативных функторов)
         \begin{lstlisting}
f : Maybe Int -> Maybe Int -> Maybe Int
f x y = [| x + y |]
         \end{lstlisting}
   \end{itemize}
\end{frame}

\begin{frame}[fragile]
   \frametitle{\dots}
   \lstset{
      emph={Bool, Delay, Lazy, Maybe, Type},
      emphstyle=\color{typecolor},
      emph={[2]Force, boolElim, g},
      emphstyle={[2]\color{namecolor}},
   }
   \begin{itemize}
   \item !-нотация(для монад)
         \begin{lstlisting}
g : Maybe Bool -> Maybe a -> Maybe a -> Maybe a
g x t f = if !x then t else f
         \end{lstlisting}
   \item Опциональная ленивость
         \begin{lstlisting}
data Lazy : Type -> Type where
   Delay : a -> Lazy a

Force : Lazy a -> a
         \end{lstlisting}
   \item Изменяемый синтаксис
         \begin{lstlisting}
syntax if [test] then [t] else [e] = boolElim test (Delay t) (Delay e)
         \end{lstlisting}
   \end{itemize}
\end{frame}

\begin{frame}[fragile]
   \frametitle{\dots}
   \lstset{
      emph={Type},
      emphstyle=\color{typecolor},
      emph={[2]},
      emphstyle={[2]\color{namecolor}},
   }
   \begin{itemize}
   \item Минимальный вывод типов в \texttt{\color{kwcolor}where}
   \item Гетерогенное равенство
      \begin{lstlisting}
data (=) : a -> b -> Type where
   refl : x = x
      \end{lstlisting}
   \item FFI with C
      TODO
   \end{itemize}
\end{frame}

\begin{frame}[fragile]
   \frametitle{\dots}
   \lstset{
      emph={Int, MkR, R, String, Type},
      emphstyle=\color{typecolor},
      emph={[2]f},
      emphstyle={[2]\color{namecolor}},
   }
   \begin{itemize}
   \item \texttt{\color{kwcolor}public}, \texttt{\color{kwcolor}abstract},
         \texttt{\color{kwcolor}private} спецификаторы видимости
      \begin{lstlisting}
%access public
abstract f : Int -> Int
      \end{lstlisting}
   \item \texttt{\color{kwcolor}record}s
      \begin{lstlisting}
record R : Type where
   MkR : (f1 : Int) -> (f2 : String) -> R
      \end{lstlisting}
   \item Levels are implicit
      TODO
   \item auto implicit args
      TODO
   \end{itemize}
\end{frame}

\begin{frame}[fragile]
   \frametitle{Effects вместо трансформеров}%TODO: Can be a topic in itself
   %TODO: What are STDIO & co? types or not
   \lstset{
      emph={Eff, Int, STDIO, STATE},
      emphstyle=\color{typecolor},
      emph={[2]f},
      emphstyle={[2]\color{namecolor}},
   }
   \begin{lstlisting}
f : { [STDIO, STATE Int] } Eff ()
   \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
   \frametitle{Type providers} %TODO: Can be a topic in itself
   \lstset{
      emph={Provide, Provider, IO, Int, Nat, Type, String},
      emphstyle=\color{typecolor},
      emph={[2]f, fromFile, strToType, trim, readFile},
      emphstyle={[2]\color{namecolor}},
   }
   \begin{lstlisting}
%language TypeProviders

strToType : String -> Type
strToType "Int" = Int
strToType _ = Nat

fromFile : String -> IO (Provider Type)
fromFile fname = Provide (strToType (trim !(readFile fname)))

%provide (T : Type) with fromFile "config.h"

f : T
f = 42
   \end{lstlisting}
\end{frame}

\frame {
   \frametitle{TODOs}
   \begin{itemize}
   \item Proof automation
   \item More better termination checker
   \item More better editor support (goto definition, autocomplete, \dots)
   \item More bindings (incl. low-level C bindings)
   \item More backends (e.g. GHC)
   \item Bugfixing
   \end{itemize}
}
